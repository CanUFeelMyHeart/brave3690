# Инструкция по работе с Git & GitHub

> **git --version** - *проверяем, установлен ли Git на компьютере, если нет - нужно будет установить.*

> **git init** - *создаем пустой репозиторий в ранее выбранной (созданной) папке.*

> **git status** - *показывает, есть ли изменения в вашем Git  (файлах), которые нужно сохранить.*

> **git add** - *добавляет (сохраняет) файл для последующего коммита.*

> **git add .** - *добавляет (сохраняет) все файлы для последующего коммита.*

> **git commit -m “message”** - *создает коммит (сохранение) с ранее добавленными файлами. если их нет - выдаст ошибку.*

> **git log** - *выводит на экран всю историю коммитов(сохранений) с их хеш-кодами (идентификаторами).*

> **git checkout** - *переключает с одной версии на другую версию сохранений файла(коммитов).*

> **git checkout master** - *возвращает к актуальной версии файла (коммиту) и позволяет продолжить работу.*

> **git diff** - *показывает разницу между текущим и сохранённым (закоммиченным) файлом.*

> **git branch** -  *команда, с помощью которой можно посмотреть список всех имеющихся веток в нашем репозитории.*

## Ветвление и работа с ветками

Чтобы создать новую ветку, используем команду :
> **git branch branch_name** - *создание новой ветки с именем branch_name*

А чтобы создать новую ветку и перейти в нее, используем команду :
> **git checkout -b branch_name**

Мы уже знакомы с командами **git add** и **git commit -m "text"**, которые помогают сохранить изменённые файлы в нашем локальном репозитории.
Но существует команда, в которой эти два действия объединены :
> **git commit -am "text"** - *команда совмещает в себе сохранение файла для дальнейшего коммита и сам коммит.*

Чтобы увидеть всю историю коммитов с их хеш-кодами мы используем команду **git log**.
Если мы добавим к данной команде **--graph**, то мы увидим не только историю коммитов, но и  коммиты в виде дерева с псевдографикой. Полноостью команда выглядит так :
> **git log --graph**

Бывает так, что некоторые файлы нужны для работы, но им не место в репозитории - их называют игнорируемыми.
**Игнорируемые файлы** — это, как правило, артефакты сборки и файлы, генерируемые машиной из исходных файлов в вашем репозитории, либо файлы, которые по какой-либо иной причине не должны попадать в коммиты. 
Вот некоторые распространенные примеры таких файлов:
- кэши зависимостей, например содержимое /node_modules или /packages;
- скомпилированный код, например файлы .o, .pyc и .class ;
- каталоги для выходных данных сборки, например /bin, /out или /target;
- файлы, сгенерированные во время выполнения, например .log, .lock или .tmp;
- скрытые системные файлы, например .DS_Store или Thumbs.db;
- личные файлы конфигурации IDE, например .idea/workspace.xml.
Игнорируемые файлы отслеживаются в специальном файле **.gitignore**, который регистрируется в корневом каталоге репозитория. В Git нет специальной команды для указания игнорируемых файлов: вместо этого необходимо вручную отредактировать файл **.gitignore**, чтобы указать в нем новые файлы, которые должны быть проигнорированы. Файлы **.gitignore** содержат шаблоны, которые сопоставляются с именами файлов в репозитории для определения необходимости игнорировать эти файлы.


## Настройка работы с удалённым репозиторием

Чтобы склонировать репозиторий к себе на ПК, используется команда :
> **git clone URL** - *клонируется репозиторий по адресу __URL__* 

Команда **git clone** составная : она не только скачивает все изменения, но и пытается слить все ветки на локальном компьютнеере и в удаленном репозитории.

Загрузить содержимое из удаленного репозитория можно с помощью двух команд: _**git pull** и **git fetch**_. 

>Из этих двух команд _**git fetch**_ можно считать «безопасным» вариантом. 
Она загружает удаленное содержимое, но не обновляет рабочее состояние локального репозитория, оставляя текущую работу нетронутой. 

>Команда _**git pull**_ действует более агрессивно: она загружает удаленное содержимое для активной локальной ветки и сразу выполняет команду _**git merge**_, создавая коммит слияния для нового удаленного содержимого. 
Если у вас есть ожидающие изменения, то возникнут конфликты, и будет запущен процесс разрешения конфликтов слияния.

> Команда _**git push**_ используется для выгрузки содержимого локального репозитория в удаленный репозиторий. 
Она позволяет передать коммиты из локального репозитория в удаленный. 
**Команда _push_ может перезаписать изменения, поэтому при ее использовании следует соблюдать осторожность**

После использования команды **git push** изменения приходит в удалённый репозиторий. Чтобы принять их или отклонить, на сайте GitHub, в выбранном ранее репозитории, можно найти кнопку **pull request**.
С помощью неё выбирается : принять ли предложенные изменения или отклонить их. 

- *Как создать pull request* :
1. Делаем fork(ответвление) удалённого репозитория
2. Делаем git clone в свой локальный репозиторий
3. Создаем новую ветку и вносим в неё изменения
4. Фиксируем изменения(git commit)
5. Отправляем свою версию в свой GitHub при помощи git push
6. На сайте GitHub подтверждаем или отклоняем изменения (pull request).